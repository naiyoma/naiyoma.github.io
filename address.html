<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin P2SH Transaction Creation Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        h2 {
            color: #2c3e50;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        h4 {
            color: #2c3e50;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        h3 {
            color: #34495e;
            margin-top: 25px;
        }

        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            position: relative;
        }

        code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 14px;
            color: #24292e;
        }

        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }

        .important {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
        }

        ul, ol {
            padding-left: 25px;
        }

        li {
            margin-bottom: 8px;
        }
        .section {
            margin: 20px 0;
        }
        ul {
            list-style-type: none;
            padding-left: 20px;
        }
        ul li {
            margin: 10px 0;
            position: relative;
        }
        ul li:before {
            content: "â€¢";
            color: #3498db;
            font-weight: bold;
            position: absolute;
            left: -15px;
        }
        .ordered-list {
            list-style-type: decimal;
            padding-left: 20px;
        }
        .ordered-list li {
            margin: 10px 0;
        }
        .ordered-list li:before {
            content: none;
        }
        .sub-list {
            margin-left: 20px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">

       <div>
        <div class="container">
            <section class="section">
                <h4>Current Implementation</h4>
                <p>This is a first iteration of this script focuses on the basic mechanism of data collection, without yet implementing Tor connectivity. The script demonstrates the fundamental aspects of the fingerprinting attack.</p>
            </section>
    
            <section class="section">
                <h4>Script flow</h4>
                <ol class="ordered-list">
                    <li>Initiates connection to a victim node running on localhost</li>
                    <li>Establishes a  handshake connection</li>
                    <li>Collects peer information by sending GetAddr requests</li>
                    <li>Scrapes and analyzes data including:
                        <ul class="sub-list">
                            <li>IP addresses</li>
                            <li>Timestamps</li>
                            <li>Service flags</li>
                        </ul>
                    </li>
                </ol>
            </section>
    
            <section class="section">
                <h4>Current Observations</h4>
                <p>The script successfully fetches peer data from the victim node. However, the retrieved IP addresses tend to remain relatively constant between requests, as nodes typically maintain a stable set of peer connections.</p>
            </section>
    
            <section class="section">
                <h4>Limitations</h4>
                <ul>
                    <li>Currently only works with clearnet connections</li>
                    <li>Connects to localhost for testing</li>
                    <li>Retrieved peer list shows limited variance between requests</li>
                </ul>
            </section>
    
            <section class="section">
                <h4>Next Steps</h4>
                <ul>
                    <li>Implement Tor connection capabilities</li>
                    <li>Extend data collection over longer time periods</li>
                    <li>Add correlation analysis between clearnet and Tor identities</li>
                </ul>
            </section>
        </div>
       </div>

        <img src="adr.png" alt="First image">
        <pre>
        <code>
            import socket
            import struct
            import time
            import random
            from hashlib import sha256
            import ipaddress
            from datetime import datetime
            
            
            def decode_netaddr(data, with_time=True):
                pos = 0
                if with_time:
                    timestamp = struct.unpack('<I', data[pos:pos+4])[0]
                    pos += 4
                else:
                    timestamp = int(time.time())
                
                services = struct.unpack('<Q', data[pos:pos+8])[0]
                pos += 8
            
                # IPV6
                ipbytes = data[pos:pos+16]
                pos += 16
            
                # Convert IPv4-mapped IPv6 address
                if ipbytes.startswith(b'\x00' * 10 + b'\xff\xff'):
                    ip = str(ipaddress.IPv4Address(ipbytes[-4:]))
                else:
                    ip = str(ipaddress.IPv6Address(ipbytes))
                
                port = struct.unpack('>H', data[pos:pos+2])[0]
            
                return {
                    'timestamp': datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S'),
                    'services': f"0x{services:x}",
                    'ip': ip,
                    'port': port
                }
            
            
            def decode_addr_message(payload):
            
                addresses = []
                pos = 0
            
                # count of address 
                count = int(payload[pos])
                pos += 1
            
                for _ in range(count):
                    if pos + 30 > len(payload):
                        break
                    
                    addr = decode_netaddr(payload[pos:pos+30])
                    addresses.append(addr)
                    pos += 30
            
                return addresses
            
            
            def create_message(command, payload=b''):
                # Magic value for mainnet
                magic = 0xD9B4BEF9
                
                # Command padding (12 bytes)
                command_bytes = command.encode('ascii') + b'\0' * (12 - len(command))
                
                # Length of payload
                length = len(payload)
                
                # Checksum is first 4 bytes of double SHA256 of payload
                if length > 0:
                    checksum = sha256(sha256(payload).digest()).digest()[:4]
                else:
                    checksum = b'\x5D\xF6\xE0\xE2'  # Checksum for empty payload
                
                # Construct message
                message = struct.pack('<L12sL4s', magic, command_bytes, length, checksum)
                if payload:
                    message += payload
                
                return message
            
            
            def parse_message_header(data):
                if len(data) < 24:  # Header is 24 bytes
                    return None, None, None, None
                
                magic, command, length, checksum = struct.unpack('<L12sL4s', data[:24])
                command = command.strip(b'\0').decode('ascii')
                return magic, command, length, checksum
            
            
            def send_getaddr():
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(30)
                    print("Connecting to node...")
                    sock.connect(('127.0.0.1', 8333))
                    
                    # Send version message
                    version = 70015
                    services = 0
                    timestamp = int(time.time())
                    addr_recv_services = struct.pack('<Q', services)
                    addr_trans_services = struct.pack('<Q', services)
                    addr_recv_ip = b'\x00' * 10 + b'\xff\xff' + socket.inet_aton('127.0.0.1')
                    addr_recv_port = struct.pack('>H', 8333)
                    addr_trans_ip = b'\x00' * 10 + b'\xff\xff' + socket.inet_aton('127.0.0.1')
                    addr_trans_port = struct.pack('>H', 8333)
                    
                    nonce = random.getrandbits(64)
                    user_agent = b"/TestNode:0.0.1/"
                    start_height = 0
                    relay = True
            
                    version_payload = struct.pack('<IQQ', version, services, timestamp)
                    version_payload += addr_recv_services + addr_recv_ip + addr_recv_port
                    version_payload += addr_trans_services + addr_trans_ip + addr_trans_port
                    version_payload += struct.pack('<Q', nonce)
                    version_payload += bytes([len(user_agent)]) + user_agent
                    version_payload += struct.pack('<I?', start_height, relay)
            
                    print("Sending version message...")
                    sock.send(create_message('version', version_payload))
                    
                    # Process responses
                    buffer = b''
                    handshake_complete = False
                    addresses = []
                    
                    while True:
                        data = sock.recv(1024)
                        if not data:
                            break
                            
                        buffer += data
                        while len(buffer) >= 24:  # Header size
                            magic, command, length = struct.unpack('<L12sL', buffer[:20])
                            command = command.strip(b'\0').decode('ascii')
                            
                            if len(buffer) < 24 + length:
                                break
                                
                            message = buffer[24:24+length]
                            buffer = buffer[24+length:]
                            
                            print(f"Received command: {command}")
                            
                            if command == 'version':
                                print("Sending verack...")
                                sock.send(create_message('verack'))
                            elif command == 'verack':
                                if not handshake_complete:
                                    print("Sending getaddr...")
                                    sock.send(create_message('getaddr'))
                                    handshake_complete = True
                            elif command == 'addr':
                                new_addresses = decode_addr_message(message)
                                addresses.extend(new_addresses)
                                print(f"Decoded {len(new_addresses)} addresses")
                                for addr in new_addresses:
                                    print(f"\nIP: {addr['ip']}:{addr['port']}")
                                    print(f"Time: {addr['timestamp']}")
                                    print(f"Services: {addr['services']}")
                                
                except Exception as e:
                    print(f"Error: {str(e)}")
                finally:
                    sock.close()
                    print("Connection closed")
                    return addresses
            
            
            if __name__ == "__main__":
                addresses = send_getaddr()
                print("\nTotal addresses received:", len(addresses))
        </code>
        </pre>
        <h4>Output from script above </h4>
        <section class="section">
            <pre>
                <code>
IP: ::ffff:2256:2036
Time: 1984-08-08 16:29:04
Services: 0x409674c

IP: ::ffff:47a7:24194
Time: 1981-06-02 21:04:16
Services: 0x409674b

IP: ::ffff:2242:14528
Time: 2010-05-02 17:33:04
Services: 0x44d674c

IP: ::ffff:4784:60834
Time: 2087-08-05 03:17:36
Services: 0x40d673b

IP: 0:2603:3007:2107:300:::1636
Time: 1993-02-12 14:42:24
Services: 0x4096748

IP: ::ffff:6e35:26041
Time: 1990-06-19 05:25:36
Services: 0x40c674a

IP: ffff:2a01:4f9:3a:3961:::2
Time: 2042-11-08 08:56:48
Services: 0xffffffffffff674c

IP: ::ffff:68f3:12459
Time: 2103-07-25 09:16:00
Services: 0xc7d674b

IP: ::ffff:1f2d:23038
Time: 1979-09-15 08:12:00
Services: 0xc496748

IP: 0:2001:bc8:1201:71a:2e59:e5ff:fe42:21236
Time: 2097-01-31 07:48:32
Services: 0x24000c49673c

Error: timed out
Connection closed

Total addresses received: 253
                </code>
            </pre>
        </section>

    </div>
    <div>
        <h3>
            Analyze timestamp Script
        </h3>
        <section class="section">
            <h4>Script Flow</h4>
            <ul>
                <li>collect timestamps from peer addresses received from the victim node</li>
                <li> groups addresses based on timestamp proximity</li>
                <li> use a time threshold (300 seconds/5 minutes) to determine which timestamps are "close enough</li>
            </ul>
            <p>
                <h4>
                    When timestamps from different addresses are very close together, it might indicate:
                </h4>
                <li>
                    The addresses belong to the same node
                </li>
                <li>
                    The addresses were discovered at the same time
                </li>
                <li>
                    The addresses are part of the same network or peer group
                </li>
            </p>
        </section>

        <pre>
            <code>
from datetime import datetime
import numpy as np
from collections import defaultdict
from getaddr_test import send_getaddr    


def analyze_timestamps(addresses, time_threshold=300):
    timestamp_groups = defaultdict(list)
    
    for addr in addresses:
        try:
            # Parse the timestamp string into a datetime object
            dt = datetime.strptime(addr['timestamp'], '%Y-%m-%d %H:%M:%S')
            unix_ts = int(dt.timestamp())
            
            timestamp_groups[unix_ts].append({
                'ip': addr['ip'],
                'port': addr['port'],
                'services': addr['services']
            })
        except (ValueError, TypeError) as e:
            print(f"Error processing timestamp for address: {addr}")
            continue
    
    print(f"\nAnalyzing {len(addresses)} addresses for timestamp correlations...")
    print(f"Using time threshold of {time_threshold} seconds")
    
    # Find related timestamps
    correlated_nodes = []
    timestamps = sorted(timestamp_groups.keys())
    
    for i in range(len(timestamps)):
        current_group = []
        base_ts = timestamps[i]
        
        for j in range(i + 1, len(timestamps)):
            if timestamps[j] - base_ts <= time_threshold:
                if not current_group:
                    current_group.extend(timestamp_groups[base_ts])
                current_group.extend(timestamp_groups[timestamps[j]])
            else:
                break
        
        if current_group:
            correlated_nodes.append({
                'timestamp': datetime.fromtimestamp(base_ts).strftime('%Y-%m-%d %H:%M:%S'),
                'nodes': current_group,
                'count': len(current_group)
            })
    
    # Print findings
    if correlated_nodes:
        print("\nFound potentially correlated nodes:")
        for group in correlated_nodes:
            print(f"\nTimestamp cluster at {group['timestamp']} with {group['count']} nodes:")
            for node in group['nodes'][:5]:  # Show first 5 nodes in each group
                print(f"  IP: {node['ip']}:{node['port']} Services: {node['services']}")
            if len(group['nodes']) > 5:
                print(f"  ... and {len(group['nodes']) - 5} more nodes")
    else:
        print("\nNo suspicious timestamp correlations found")
    
    return correlated_nodes


def detect_fingerprinting(addresses):
    print("\nAnalyzing for potential fingerprinting patterns...")
    
    # Group by /16 subnets
    subnet_groups = defaultdict(list)
    for addr in addresses:
        try:
            if '::ffff:' in addr['ip']:  # Handle IPv4-mapped-IPv6 addresses
                ip_parts = addr['ip'].split(':')[-1].split('.')
                subnet = '.'.join(ip_parts[:2])
                subnet_groups[subnet].append(addr)
        except Exception as e:
            print(f"Error processing IP address: {addr}")
            continue
    
    suspicious_patterns = []
    
    for subnet, nodes in subnet_groups.items():
        if len(nodes) < 3:  # Need at least 3 nodes for meaningful analysis
            continue
        
        # Analyze timestamp patterns
        timestamps = []
        for node in nodes:
            try:
                dt = datetime.strptime(node['timestamp'], '%Y-%m-%d %H:%M:%S')
                timestamps.append(int(dt.timestamp()))
            except (ValueError, TypeError) as e:
                print(f"Error processing timestamp in subnet analysis: {node}")
                continue
        
        if len(timestamps) < 3:  # Skip if we don't have enough valid timestamps
            continue
            
        timestamps.sort()
        time_diffs = np.diff(timestamps)
        
        if len(time_diffs) > 0:
            mean_diff = np.mean(time_diffs)
            std_diff = np.std(time_diffs)
            
            # Check for suspiciously regular patterns
            if std_diff < mean_diff * 0.1:
                suspicious_patterns.append({
                    'subnet': subnet,
                    'node_count': len(nodes),
                    'mean_time_diff': mean_diff,
                    'std_diff': std_diff,
                    'nodes': nodes
                })
    
    # Print findings
    if suspicious_patterns:
        print("\nFound suspicious patterns that might indicate fingerprinting:")
        for pattern in suspicious_patterns:
            print(f"\nSubnet: {pattern['subnet']}")
            print(f"Node count: {pattern['node_count']}")
            print(f"Mean time difference: {pattern['mean_time_diff']:.2f} seconds")
            print(f"Time difference standard deviation: {pattern['std_diff']:.2f}")
            print("Sample nodes:")
            for node in pattern['nodes'][:3]:  # Show first 3 nodes
                print(f"  IP: {node['ip']}:{node['port']} Time: {node['timestamp']}")
    else:
        print("\nNo suspicious fingerprinting patterns detected")
    
    return suspicious_patterns


if __name__ == "__main__":
    print("Fetching addresses from Bitcoin network...")
    addresses = send_getaddr()
    
    if addresses:
        print(f"\nReceived {len(addresses)} addresses")
        
        # Analyze timestamp correlations
        correlated = analyze_timestamps(addresses)
        
        # Look for fingerprinting patterns
        suspicious = detect_fingerprinting(addresses)
        
        # Print summary
        print("\nAnalysis Summary:")
        print(f"Total addresses analyzed: {len(addresses)}")
        print(f"Correlated timestamp groups found: {len(correlated)}")
        print(f"Suspicious fingerprinting patterns found: {len(suspicious)}")
    else:
        print("No addresses received to analyze")
            </code>
        </pre>
    </div>
    <section class="section"></section>
    <h4>Sample Output</h4>
    <pre>
        <code>
Received 253 addresses

Analyzing 253 addresses for timestamp correlations...
Using time threshold of 300 seconds

No suspicious timestamp correlations found

Analyzing for potential fingerprinting patterns...

No suspicious fingerprinting patterns detected

Analysis Summary:
Total addresses analyzed: 253
Correlated timestamp groups found: 0
Suspicious fingerprinting patterns found: 0

        </code>
    </pre>

        <div>
            <a href="address.html"></a>
        </div>
</body>
</html>